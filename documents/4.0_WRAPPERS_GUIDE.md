# Wrappers Guide

## 4. Wrappers (`{root}/src/wrappers`)

**Purpose:** Type-safe, consistent interfaces for third-party libraries, external APIs, and system-level utilities. Single point of integration between external dependencies and application codebase.

**Key Benefits:** Type safety (eliminate `any`), consistent error handling (`AppError`), standardized logging, abstraction, maintainability.

**Required Wrappers for This Project:** See [9.0_INTEGRATIONS.md](./9.0_INTEGRATIONS.md) for complete list:
- `ClerkWrapper` - User authentication and management
- `PayoneerWrapper` - Payment processing
- `MailgunWrapper` - Email sending/receiving (HS code classification)
- `WhatsAppBusinessWrapper` - WhatsApp messaging (HS code classification)
- `OpenAIWrapper` - OpenAI API client (GPT-4, GPT-3.5)
- `AnthropicWrapper` - Anthropic API client (Claude 3)
- `GoogleGeminiWrapper` - Google Gemini API client
- `XAIWrapper` - xAI Grok API client

### When to Create Wrappers

Create when encountering:
1. Third-party libraries with incomplete/incorrect TypeScript types
2. External APIs requiring request/response transformation or error normalization
3. System-level operations (file system, network, process) needing error boundaries
4. React components from external libraries requiring prop normalization or ref forwarding
5. Code that would otherwise require `@ts-expect-error`, `@ts-ignore`, or `any` types
6. Repeated patterns of error handling or logging around the same dependency

**Do NOT create for:** Simple well-typed utilities, internal project code (use shared utilities), dependencies matching project conventions perfectly.

### Structure Requirements

**File Organization:**
- One wrapper per file: `{root}/src/wrappers/{WrapperName}.ts` or `.tsx`
- Naming: PascalCase matching wrapped entity (e.g., `ClerkWrapper.ts`, `PostgresWrapper.ts`)
- Exports: Single well-typed interface or component
- Co-location: Keep related types in same file, or import from `src/shared`

**Component Wrappers:**
```typescript
// Generic components
function WrapperComponent<T extends string>(props: WrapperProps<T>) { ... }

// Non-generic components
const WrapperComponent: React.FC<WrapperProps> = React.forwardRef<HTMLElement, WrapperProps>(
  (props, ref) => { ... }
);
```

**Requirements:** Function declarations for generics, named arrow functions with `React.FC` for non-generics, always forward refs for DOM components, minimal explicit prop interfaces, document prop transformations.

### Type Safety Rules

**Strict Typing:**
- No `any` types in public interfaces
- Internal type assertions (`as`) allowed only when: necessary to bridge type gaps, documented with inline comments, isolated to implementation details

**Type Suppression:**
`@ts-expect-error` **may only** appear inside wrapper files, **must not** be used elsewhere.

**Before using `@ts-expect-error`, exhaust in order:**
1. Utility Types (`Omit`, `Pick`, `Partial`, `Required`, `Record`, etc.)
2. Type Guards (runtime checks with type narrowing)
3. Generic Constraints (`extends` to constrain parameters)
4. Module Augmentation (`declare module` to extend third-party types)
5. Type Mapping (mapped types to transform existing types)
6. Conditional Types (complex type transformations)

**When `@ts-expect-error` is necessary:**
```typescript
// ❌ Bad: No explanation
// @ts-expect-error
const result = libraryFunction(data);

// ✅ Good: Documented with reason
// @ts-expect-error - Library types incorrect for v2.1.0, see: https://github.com/lib/issues/123
// Expected: string[], Actual: string | string[]
const result = libraryFunction(data);
```

**Each suppression must include:** Comment explaining why, reference to underlying issue, expected vs. actual type information when relevant.

### Integration with Project Utilities

**Error Handling:** Use `AppError` and error handling utilities (to be created in `config/error-handling.ts`):
```typescript
try {
  // Wrapped operation
} catch (error) {
  if (error instanceof Error) {
    handleApiError(error, 'WrapperName', 'method', 'url');
    throw new AppError('User-friendly message', { cause: error });
  }
  throw error;
}
```

**Logging:** Use logging utilities with context prefixes:
```typescript
logInfo('Operation started', { prefix: '[WrapperName]' });
const startTime = Date.now();
// ... operation ...
logPerformance('Operation completed', Date.now() - startTime, { prefix: '[WrapperName]' });
```

**File System:** When `FSWrapper` is implemented, use it for all file system operations instead of direct `fs` calls.

### Examples

**API Client Wrapper:**
```typescript
export class ApiClientWrapper {
  async get<T>(endpoint: string): Promise<ApiClientResponse<T>> {
    try {
      const response = await fetch(`${this.config.baseUrl}${endpoint}`, {
        headers: { 'Authorization': `Bearer ${this.config.apiKey}` },
        signal: AbortSignal.timeout(this.config.timeout ?? 5000),
      });
      if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
      return { data: await response.json() as T, status: response.status, headers: ... };
    } catch (error) {
      if (error instanceof Error) handleApiError(error, 'ApiClientWrapper', 'GET', endpoint);
      throw error;
    }
  }
}
```

**React Component Wrapper:**
```typescript
export const WrappedButton = React.forwardRef<HTMLButtonElement, WrappedButtonProps>(
  ({ label, variant = 'primary', onClick, disabled }, ref) => {
    const externalProps = { text: label, style: variant === 'primary' ? 'filled' : 'outlined', ... };
    // @ts-expect-error - External library ref type incorrect (v3.2.1), see: https://github.com/lib/issues/456
    return <ExternalButton ref={ref} {...externalProps} />;
  }
);
```

### Testing Requirements

- Test wrapper behavior, not implementation details
- Verify type safety in tests (use `expectTypeOf` from `vitest` or similar)
- Mock underlying dependencies appropriately
- Test error handling paths
- Test prop transformations and default behaviors

### Best Practices

1. Keep wrappers thin: Focus on type safety and error handling, not business logic
2. Document decisions: Explain why wrapper exists and what problems it solves
3. Version awareness: Note which versions of dependencies wrapper supports
4. Progressive enhancement: Start with minimal wrapping, add features as needed
5. Consistent patterns: Follow established patterns from existing wrappers
6. Regular review: Update wrappers when dependencies change or better solutions emerge

### Migration Path

When migrating from unwrapped code:
1. Identify all uses of the dependency
2. Create wrapper with minimal interface
3. Replace usages one at a time
4. Test each replacement
5. Remove direct imports of the dependency
6. Update wrapper as needed based on usage patterns

---

## Related Documentation

- [1.0_PRINCIPLES.md](./1.0_PRINCIPLES.md) - Core principles
- [2.0_PROJECT_RULES.md](./2.0_PROJECT_RULES.md) - Project rules
- [9.0_INTEGRATIONS.md](./9.0_INTEGRATIONS.md) - Third-party integrations (Clerk, Payoneer, Mailgun, WhatsApp wrappers)

